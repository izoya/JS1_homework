{"version":3,"sources":["Board.js","Food.js","Game.js","Main.js","Menu.js","Settings.js","Snake.js","status.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../app.js","sourcesContent":["class Board {\r\n    constructor() {\r\n    this.boardEl = document.getElementById('game');\r\n    }\r\n\r\n    /**\r\n     * Метод получает другие игровые объекты,\r\n     * которые нужны ему для работы.\r\n     * @param settings {Settings} объект настроек\r\n     * @param snake {Snake} объект змейки\r\n     */\r\n    init(settings, snake) {\r\n        this.settings = settings;\r\n        this.snake = snake;\r\n    }\r\n\r\n\r\n    renderBoard() {\r\n        this.boardEl.innerHTML = '';\r\n        for (let row = 0; row < this.settings.rowsCount; row++) {\r\n            let tr = document.createElement('tr');\r\n            this.boardEl.appendChild(tr);\r\n\r\n            for (let col = 0; col < this.settings.colsCount; col++) {\r\n                let td = document.createElement('td');\r\n                tr.appendChild(td);\r\n            }\r\n        }\r\n    }\r\n\r\n    renderSnake() {\r\n        let snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\r\n        snakeBodyElems.forEach(function (tdEl) {\r\n            tdEl.classList.add('snakeBody');\r\n        });\r\n    }\r\n\r\n    clearBoard() {\r\n        const tdElems = document.querySelectorAll('td');\r\n        tdElems.forEach((td) => td.className = \"\");\r\n    }\r\n\r\n    renderFood(coords) {\r\n        const foodCell = this.getCellEl(coords.x, coords.y);\r\n        foodCell.classList.add('food');\r\n    }\r\n\r\n\r\n    getSnakeBodyElems(bodyCoords) {\r\n        if (bodyCoords.length > 0) {\r\n            let bodyElems = [];\r\n            for (let value of bodyCoords) {\r\n                let elem = this.getCellEl(value.x, value.y);\r\n                bodyElems.push(elem);\r\n            }\r\n            return bodyElems;\r\n        }\r\n        throw new Error('Объект змейки нулевой длины или не существует.');\r\n    }\r\n\r\n    isNextStepToWall(nextCellCoords) {\r\n        let nextCell = this.getCellEl(nextCellCoords.x, nextCellCoords.y);\r\n        return nextCell === null;\r\n    }\r\n\r\n    /**\r\n     * Метод возвращает ссылку на ячейку по указанным координатам\r\n     * @param {int} x, y - координаты ячейки\r\n     * @returns {HTMLElement} - ссылка на ячейку\r\n     */\r\n    getCellEl(x, y) {\r\n        return this.boardEl.querySelector(`tr:nth-child(${y}) td:nth-child(${x})`);\r\n    }\r\n\r\n    isHeadOnFood() {\r\n        return this.boardEl.querySelector('.food').classList.contains('snakeBody');\r\n    }\r\n\r\n}","class Food {\r\n    constructor() {\r\n        this.x = null;\r\n        this.y = null;\r\n    }\r\n\r\n    init(settings, snake, board) {\r\n        this.settings = settings;\r\n        this.snake = snake;\r\n        this.board = board;\r\n    }\r\n\r\n    setNewFood() {\r\n        const food = this.generateRandomCoords();\r\n        this.board.renderFood(food);\r\n    }\r\n\r\n    setFood() {\r\n        this.board.renderFood(this);\r\n    }\r\n\r\n    generateRandomCoords() {\r\n        while (true) {\r\n            this.x = Math.floor(Math.random() * this.settings.colsCount) + 1;\r\n            this.y = Math.floor(Math.random() * this.settings.rowsCount) + 1;\r\n\r\n            let cell = this.board.getCellEl(this.x, this.y);\r\n\r\n            if (cell.classList.contains('snakeBody')) continue;\r\n            /** TODO return cell ? */\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n}","class Game {\r\n    constructor() {\r\n        this.tickId = null;\r\n        this.messageEl = document.getElementById('message');\r\n    }\r\n\r\n    init(settings, snake, board, food, menu, status) {\r\n        this.settings = settings;\r\n        this.snake = snake;\r\n        this.board = board;\r\n        this.food = food;\r\n        this.menu = menu;\r\n        this.status = status;\r\n    }\r\n\r\n    run() {\r\n        // bind() закрепляет this для вызываемой функции, в данном случае this - это объект Game\r\n        this.menu.addButtonsClickListeners(this.start.bind(this), this.pause.bind(this));\r\n        document.addEventListener('keydown', this.pressKeyHandler.bind(this));\r\n    }\r\n\r\n    start() {\r\n        if (this.status.isPaused()) {\r\n            this.status.setPlaying();\r\n            this.tickId = setInterval(this.doTick.bind(this), 1000 / this.settings.speed);\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        if (this.status.isPlaying()) {\r\n            this.status.setPaused();\r\n            clearInterval(this.tickId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод запускается по интервалу и осуществляет:\r\n     * 1. Перемещение змейки\r\n     * 2. Проверку на конец игры\r\n     * 3. Увеличение размераа змейки, если она съела еду\r\n     * 4. Отрисовку заново змейки и еды\r\n     */\r\n    doTick() {\r\n        this.snake.performStep();\r\n        if (this.isGameLost()) {\r\n            return;\r\n        }\r\n        if (this.isGameWon()) {\r\n            return;\r\n        }\r\n        if (this.board.isHeadOnFood()) {\r\n            this.snake.increaseBody();\r\n            this.food.setNewFood();\r\n        }\r\n        this.board.clearBoard();\r\n        this.food.setFood();\r\n        this.board.renderSnake();\r\n    }\r\n\r\n    pressKeyHandler(event) {\r\n        switch (event.key) {\r\n            case \"ArrowUp\":\r\n                this.snake.changeDirection('up');\r\n                break;\r\n            case \"ArrowDown\":\r\n                this.snake.changeDirection('down');\r\n                break;\r\n            case \"ArrowRight\":\r\n                this.snake.changeDirection('right');\r\n                break;\r\n            case \"ArrowLeft\":\r\n                this.snake.changeDirection('left');\r\n                break;\r\n        }\r\n    }\r\n\r\n    isGameLost() {\r\n        if (this.board.isNextStepToWall(this.snake.body[0])) {\r\n            clearInterval(this.tickId);\r\n            this.setMessage('Вы проиграли');\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isGameWon() {\r\n        if (this.snake.body.length == this.settings.winLength) {\r\n            clearInterval(this.tickId);\r\n            this.setMessage('Вы выиграли');\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    setMessage(text) {\r\n        this.messageEl.innerText = text;\r\n    }\r\n}","window.addEventListener('load', () => {\r\n    const settings = new Settings();\r\n    const status = new Status();\r\n    const snake = new Snake();\r\n    const board = new Board();\r\n    const food = new Food();\r\n    const game = new Game();\r\n    const menu = new Menu();\r\n\r\n    settings.init({speed: 7, winLength: 10});\r\n    board.init(settings, snake);\r\n    food.init(settings, snake, board);\r\n    game.init(settings, snake, board, food, menu, status);\r\n\r\n    board.renderBoard();\r\n    board.renderSnake();\r\n\r\n    food.setNewFood();\r\n    game.run();\r\n});\r\n//# sourceMappingURL=maps/app.js.map","class Menu {\r\n    constructor() {\r\n        this.startBtnEl = document.getElementById('startBtn');\r\n        this.pauseBtnEl = document.getElementById('pauseBtn');\r\n    }\r\n\r\n    addButtonsClickListeners(startBtnClickHandler, pauseBtnClickHandler) {\r\n        this.startBtnEl.addEventListener('click', startBtnClickHandler);\r\n        this.pauseBtnEl.addEventListener('click', pauseBtnClickHandler);\r\n    }\r\n\r\n\r\n}\r\n\r\n","class Settings {\r\n    /**\r\n     *\r\n     * @param params {Object} - Параметры игры\r\n     * @param params.rowsCount {number} - Кол-во строк игрового поля\r\n     * @param params.colsCount {number} - Кол-во колонок игрового поля\r\n     * @param params.speed {number} - Скорость змейки\r\n     * @param params.winLength {number} - Длина змейки, чтобы выиграть\r\n     * @throws {Error} - Ошибка при передаче неверных настроек\r\n     */\r\n    init(params) {\r\n        let defaultParams = {rowsCount: 21, colsCount: 21, speed: 2, winLength: 50};\r\n        Object.assign(defaultParams, params);\r\n\r\n        if (defaultParams.rowsCount < 10 || defaultParams.rowsCount > 30) {\r\n            throw new Error('Неверные настройки, rowsCount должен быть в диапазоне от 10 до 30');\r\n        }\r\n        this.rowsCount = defaultParams.rowsCount;\r\n\r\n        if (defaultParams.colsCount < 10 || defaultParams.colsCount > 30) {\r\n            throw new Error('Неверные настройки, colsCount должен быть в диапазоне от 10 до 30');\r\n        }\r\n        this.colsCount = defaultParams.colsCount;\r\n\r\n        if (defaultParams.speed < 1 || defaultParams.speed > 10) {\r\n            throw new Error('Неверные настройки, speed должен быть в диапазоне от 1 до 10');\r\n        }\r\n        this.speed = defaultParams.speed;\r\n\r\n        if (defaultParams.winLength < 5 || defaultParams.winLength > 50) {\r\n            throw new Error('Неверные настройки, winLength должен быть в диапазоне от 5 до 50');\r\n        }\r\n        this.winLength = defaultParams.winLength;\r\n    }\r\n};","class Snake {\r\n    constructor() {\r\n        this.possibleDirections = ['down', 'up', 'left', 'right'];\r\n\r\n        this.body = [\r\n            {\r\n                x: 1,\r\n                y: 1\r\n            }\r\n        ];\r\n        this.direction = 'down';\r\n    }\r\n\r\n    changeDirection(newDirection) {\r\n        if (!this.possibleDirections.includes(newDirection)) {\r\n            throw new Error('Передано неверное направление (' + newDirection + ').');\r\n        }\r\n        if (this.isPassedOppositeDirection(newDirection)) {\r\n            return;\r\n        }\r\n        this.direction = newDirection;\r\n    }\r\n\r\n    isPassedOppositeDirection(newDirection) {\r\n        if (this.direction == 'down' && newDirection == 'up') {\r\n            return true;\r\n        }\r\n        if (this.direction == 'up' && newDirection == 'down') {\r\n            return true;\r\n        }\r\n        if (this.direction == 'left' && newDirection == 'right') {\r\n            return true;\r\n        }\r\n        if (this.direction == 'right' && newDirection == 'left') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    performStep() {\r\n        let currentHeadCoords = this.body[0];\r\n        let newHeadCoords = {\r\n            x: currentHeadCoords.x,\r\n            y: currentHeadCoords.y\r\n        };\r\n        switch (this.direction) {\r\n            case \"down\":\r\n                newHeadCoords.y++;\r\n                break;\r\n            case \"up\":\r\n                newHeadCoords.y--;\r\n                break;\r\n            case \"left\":\r\n                newHeadCoords.x--;\r\n                break;\r\n            case \"right\":\r\n                newHeadCoords.x++;\r\n                break;\r\n        }\r\n        this.body.unshift(newHeadCoords);\r\n        this.body.pop();\r\n    }\r\n\r\n    increaseBody() {\r\n        let bodyLastCell = this.body[this.body.length - 1];\r\n        let newBodyLastCell = {\r\n            x: bodyLastCell.x,\r\n            y: bodyLastCell.y\r\n        };\r\n        /** TODO А почему сразу bodyLastCell не вставить в массив? */\r\n        this.body.push(newBodyLastCell);\r\n    }\r\n}","/** Здесь хранится статус игры: играем, пауза, завершено. */\r\n\r\nclass Status {\r\n    constructor() {\r\n        this.setPaused();\r\n    }\r\n\r\n    setPlaying() {\r\n        this.condition = 'playing';\r\n    }\r\n\r\n    setPaused() {\r\n        this.condition = 'paused';\r\n    }\r\n\r\n    isPlaying() {\r\n        return this.condition === 'playing';\r\n    }\r\n\r\n    isPaused() {\r\n        return this.condition === 'paused';\r\n    }\r\n}"]}